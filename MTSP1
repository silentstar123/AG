%% 多旅行商问题的遗传算法
tic
% 39个城市，4条线路
clear,clc
close all
city_distance=
city_location=
value_final=
%第一列为重量，第二列为体积
daijia =
%代价第一列为重量，第二列为底面
lu_number =5;
City_Number=38;         %城市数量
Race_Number=200;        %种群数量
Iteration=200;          %迭代次数
P_Cross=0.6;            %交叉概率
P_Mutation=0.2;         %变异概率
car_loud = 20000;           %车的载重
car_value_fund =500;   %车辆固定成本
sudu = 80;
gongzuoshichang =11;
zuichangjuli = sudu*gongzuoshichang;
car_value_trans=8;      %车辆运输成本
cemian=10.2*3.1;
cheshuju=[car_loud cemian car_value_fund car_value_trans zuichangjuli];
cangku =0.3;            %仓库成本
car_chang = 6.8;           %车的长
car_kuan = 2.4;           %车的宽
car_gao = 2.7;           %车的高

car_rongji = 40;           %车的容积
zhong=[[5;750;35;0.500000000000000;850;230;6;55;41;230;69;2990;100;245;230;120;3;10;0.00950000000000000;33;3;0.0800000000000000;0.200000000000000;275;0.500000000000000;641;10.5000000000000;79;160;1;20.7000000000000;14;0.0500000000000000;19.5000000000000;0.0785000000000000;32;192;60;55;2240]]
race=zeros(Race_Number,City_Number+lu_number);
race_best=[];
dai_best=[];
daijiadangqian=inf;
for i=1:Race_Number                         %初始化种群
    temp=randperm(City_Number)+1;
    route=[1,temp,1,1,1,1];
   
    race(i,:)=route;
end
for t=1:Iteration
    adaptation=ga_adaptation(race,city_distance,daijia,cheshuju);
    race=ga_choose(race,adaptation);
    race=ga_cross(race,P_Cross,lu_number);
    race=ga_mutation(race,P_Mutation);
    race=ga_exchange(race,P_Cross);
    race=ga_invert(race,P_Cross);
    [path,val]=ga_plot(race,city_location,city_distance,daijia,cheshuju);
    best_path=path;
    best_value=val;
    if  best_value<daijiadangqian
        race_best = best_path;
        dai_best=[dai_best,best_value];
        daijiadangqian=best_value;
    else
        dai_best=[dai_best,daijiadangqian];
    end
    %pause(0.1);
end
pinggu =[];
figure
plot(dai_best);
danrace = race_best;
cc =length(danrace);
danra_s = find(danrace==1);
pinci = length(danra_s)-1;
if danra_s(1)~=1
     r_new =[danrace(danra_s(1):cc),danrace(1:danra_s(1)-1)];
else
     r_new =danrace;
end
danra_s = find(r_new==1);
if danra_s(pinci+1)~=1
    for j=1:pinci%衡量各段代价
        if danra_s(j) ==danra_s(j+1)-1
        else
             r_n = r_new(danra_s(j)+1:danra_s(j+1)-1);
             [val] = ga_val( r_n-1,daijia,cheshuju,value_final);
             pinggu =[pinggu;val];
             lujing =[1,r_n,1];
             figure
             [a,b] = ga_plot(lujing,city_location,city_distance,daijia,cheshuju );
             
        end
        
        
    end
    if danra_s(pinci+1)~=cc
             r_n = r_new(danra_s(pinci+1)+1:cc);
             [val] = ga_val(r_n-1,daijia,cheshuju,value_final);
             pinggu =[pinggu;val];
             lujing =[1,r_n,1];
             figure
             [a,b] = ga_plot(lujing,city_location,city_distance,daijia,cheshuju );
             
     end
else
    r_n = r_new(danra_s(lu_number)+1:cc);
    [val] = ga_val(r_n-1,daijia,cheshuju,value_final);
             pinggu =[pinggu;val];
    lujing =[1,r_n,1];
    [a,b] = ga_plot(lujing,city_location,city_distance,daijia,cheshuju );    
end
toc
%%
function [val] = ga_val(race,daijia,cheshuju,value_final)
%第一个值为载重，第二个值为体积，车辆数目
val = zeros(1,3);
k=value_final(race,1);
val(1)=sum(k);
val(2)=sum(value_final(race,2));
mianji = sum(daijia(race,2));
zhong = sum(daijia(race,1));
ch1 = ceil(mianji/cheshuju(2));
ch2 = ceil(zhong/cheshuju(1));
car = max(ch1,ch2);
val(3)=car;
end
function [ adaptation ] = ga_adaptation( race,city_distance,daijia,cheshuju)
[m,n]=size(race);
adaptation_1=zeros(1,m);
for i=1:m
    path1=0;
    path2=0;
    danrace = race(i,:);
    cc =length(danrace);
    danra_s = find(danrace==1);
    pinci = length(danra_s)-1;
    if danra_s(1)~=1
        r_new =[danrace(danra_s(1):cc),danrace(1:danra_s(1)-1)];
    else
        r_new =danrace;
    end
    danra_s = find(r_new==1);
    if danra_s(pinci+1)~=1
    for j=1:pinci%衡量各段代价
        if danra_s(j) ==danra_s(j+1)-1
%             path1=path1;
%             path2=path2;
        else
             r_n = r_new(danra_s(j)+1:danra_s(j+1)-1);
             r_n1=r_n-1;
             mianji = sum(daijia(r_n1,2));
             zhong = sum(daijia(r_n1,1));
             ch1 = ceil(mianji/cheshuju(2));
             ch2 = ceil(zhong/cheshuju(1));
             car = max(ch1,ch2);
             lujing =[1,r_n,1];
             lu_len = length(lujing)-1;
             changdu=0;
             for k =1:lu_len
                 changdu = city_distance(lujing(k),lujing(k+1))+changdu;
             end
             if changdu>cheshuju(5)
                  path1 = path1+100000000;
             end
              path1=changdu*car*cheshuju(4)+path1;
              path2=car*cheshuju(3)+path2;
        end
        if danra_s(pinci+1)~=cc
            r_n = r_new(danra_s(pinci+1)+1:cc);
             r_n1=r_n-1;
             mianji = sum(daijia(r_n1,2));
             zhong = sum(daijia(r_n1,1));
             ch1 = ceil(mianji/cheshuju(2));
             ch2 = ceil(zhong/cheshuju(1));
             car = max(ch1,ch2);
             lujing =[1,r_n,1];
             lu_len = length(lujing)-1;
             changdu=0;
             for k =1:lu_len
                 changdu = city_distance(lujing(k),lujing(k+1))+changdu;
             end
              path1=changdu*car*cheshuju(4)+path1;
              path2=car*cheshuju(3)+path2;
        end
        
    end
    
    else
         r_n = r_new(danra_s(4)+1:cc);
         r_n1=r_n-1;
             mianji = sum(daijia(r_n1,2));
             zhong = sum(daijia(r_n1,1));
             ch1 = ceil(mianji/cheshuju(2));
             ch2 = ceil(zhong/cheshuju(1));
             car = max(ch1,ch2);
             lujing =[1,r_n,1];
             lu_len = length(lujing)-1;
             changdu=0;
             for k =1:lu_len
                 changdu = city_distance(lujing(k),lujing(k+1))+changdu;
             end
              path1=changdu*car*cheshuju(4)+path1;
              path2=car*cheshuju(3)+path2;
    end
    adaptation_1(i)=path1+path2;
    
end
adaptation = adaptation_1;
end
function [ race_new ] = ga_select( race,adaptation )
%赌轮盘选择
[m,n]=size(race);
race_new=zeros(m,n);
total=sum(adaptation);
probability=zeros(1,m);
wheel=zeros(1,m+1);
for i=1:m
    probability(i)=adaptation(i)/total;
    if(i==1)
        wheel(i+1)=probability(i);
    else
        wheel(i+1)=wheel(i)+probability(i);
    end
end
for i=1:m
    temp=rand;
    for j=1:m
        if(temp>=wheel(j)&&temp<=wheel(j+1))
            race_new(i,:)=race(j,:);
        end
    end
end
end
function [ best_path,val ] = ga_plot( race,city_location,city_distance,daijia,cheshuju )
    
    [m,n]=size(race);
    point=zeros(n,2);
    adaptation=ga_adaptation(race,city_distance,daijia,cheshuju);
    [val,index]=min(adaptation);
    best_path=race(index,:);
    for i=1:n
        point(i,:)=city_location(best_path(i),:);
    end
    plot(point(:,1),point(:,2),'-o',point(:,1),point(:,2),'r.');
    yyy = length(best_path);
    for lu =1:yyy
        text(point(lu,1),point(lu,2),num2str(best_path(lu)))
    end
end
function [ race_new ] = ga_mutation( race,P_Mutation )
%变异
%随机取两点，交换两点基因型
[m,n]=size(race);
race_new=race;
for i=1:m
    flag=rand;
    if(flag<=P_Mutation)
        list=randperm(n);
        temp=race_new(i,list(1));
        race_new(i,list(1))=race_new(i,list(2));
        race_new(i,list(2))=temp;
    end
end
end
function [ race_new ] = ga_invert( race,P_Cross )
%倒序
%随机取两点，逆转两点之间的基因排列
[m,n]=size(race);
race_new=race;
for i=1:m
    flag=rand;
    if(flag<P_Cross)
        temp=race_new(i,:);
        list=randperm(n);
        if(list(1)>list(2))
            start=list(2);
            finish=list(1);
        else
            start=list(1);
            finish=list(2);
        end
        temp_1=temp(1:1:start-1);
        temp_2=temp(finish:-1:start);
        temp_3=temp(finish+1:end);
        temp=[temp_1,temp_2,temp_3];
        race_new(i,:)=temp;
    end
end

end

function [ race_new ] = ga_exchange( race,P_Cross )
%ga_exchange实现随机取某一基因点，交换该点和紧跟后面一点的基因型
[m,n]=size(race);
race_new=race;
for i=1:m
    flag=rand;
    if(flag<P_Cross)
      list=randperm(n-1);
      temp=race_new(i,list(1));
      race_new(i,list(1))=race_new(i,list(1)+1);
      race_new(i,list(1)+1)=temp;
    end
end
end

function [ race_new ] = ga_cross( race,P_Cross,lu_number)
%顺序交叉
k=race(1,1);
[m,n]=size(race);
race=race(1:m,1:n);
[m,n]=size(race);
race_new=race;
for i=1:m-1
    flag=rand;%判断是否进行交叉
    if(flag<=P_Cross)
        list=randperm(n-1);
        Cross_Node=list(1);%寻找拼合点
        parent_1=race_new(i,:);
        parent_2=race_new(i+1,:);%挑选一对父母
        s1 = parent_1(1:Cross_Node);
        chuxian = sum(s1(s1==1));
        res1 = setdiff(parent_2, s1, 'stable');
        child=[s1,res1];
        dai = lu_number-chuxian;
        ZS = lu_number-1;
        if dai>ZS
            dai =ZS;
        end
        while dai>0
            t =length(child);
            list=randperm(t-1);
            Cross_Node=list(1);%寻找拼合点
            child =[child(1:Cross_Node),1,child(Cross_Node+1:t)];
            dai = dai-1;
        end
        race_new(i,:)=child;
    end
end

end

function [ race_new ] = ga_choose( race,adaptation )
%精英选择策略
%随机取种群的1/10，保留最优值，循环m次，competition_number可根据需要调整
[m,n]=size(race);
race_new=zeros(m,n);
competition_number=floor(m/10);
for i=1:m
    competition=zeros(1,competition_number);
    temp=randperm(m);
    for j=1:competition_number
        competition(1,j)=adaptation(temp(j));
    end
    [val,index]=min(competition);
    race_new(i,:)=race(temp(index),:);
end
end

